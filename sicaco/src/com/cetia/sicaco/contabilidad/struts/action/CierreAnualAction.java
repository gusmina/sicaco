/*
 * Generated by MyEclipse Struts
 * Template path: templates/java/JavaClass.vtl
 */
package com.cetia.sicaco.contabilidad.struts.action;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts.action.ActionErrors;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.apache.struts.action.ActionMessage;
import org.apache.struts.action.ActionMessages;
import org.hibernate.Session;
import org.hibernate.Transaction;

import com.cetia.sicaco.contabilidad.struts.form.CierreAnualForm;
import com.cetia.sicaco.hibernate.ConCpaConceptoPartida;
import com.cetia.sicaco.hibernate.ConCueCuenta;
import com.cetia.sicaco.hibernate.ConCueCuentaDAO;
import com.cetia.sicaco.hibernate.ConDpaDetallePartida;
import com.cetia.sicaco.hibernate.ConDpaDetallePartidaDAO;
import com.cetia.sicaco.hibernate.ConPcoPartidaContable;
import com.cetia.sicaco.hibernate.ConPcoPartidaContableDAO;
import com.cetia.sicaco.hibernate.ConSacSaldosAnterioresCuenta;
import com.cetia.sicaco.hibernate.ConSacSaldosAnterioresCuentaDAO;
import com.cetia.sicaco.hibernate.CtaChkChequePrestamo;
import com.cetia.sicaco.struts.Constantes;
import com.cetia.sicaco.struts.DMLAction;
import com.mad.utilidades.ElapsedTime;

/** 
 * MyEclipse Struts
 * Creation date: 12-22-2008
 * 
 * XDoclet definition:
 * @struts.action path="/cierreAnual" name="cierreAnualForm" parameter="accion" scope="request"
 * @struts.action-forward name="dml" path="pagina-dml.contabilidad.cierreAnual"
 */
public class CierreAnualAction extends DMLAction {
	
	
	private static final String conceptoCierreGastos = "Liquidacion de gastos periodo ";
	private static final String conceptoCierreIngresos = "Liquidacion de ingresos periodo ";
	private static final String conceptoCierreReservas = "Obtencion de reservas periodo ";
	private static final String conceptoCierreUtilidades = "Obtencion de utilidades periodo ";
	private static final String conceptoCierreDeficit = "Registro de perdidas periodo ";
	private static final String conceptoCierreAnual = "Partida de cierre anual periodo  ";
	private static final String conceptoApertura = "Partida de apertura de ejercicio  ";
	
	public ActionForward dml(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response) {
		ConCueCuentaDAO cuentaDAO = new ConCueCuentaDAO(getSessionHibernate(request));
		form = new CierreAnualForm();
		request.setAttribute("form", form);
		request.setAttribute("cuentas", cuentaDAO.findAllCodNameByEstadoForEstConf(1));
		request.setAttribute(Constantes.ACCION_KEY, "/cierreAnual");
		return mapping.findForward("dml");
	}
	
	public ActionForward realizarCierre(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response) {
		ActionErrors errors = new ActionErrors();
		Session session = getSessionHibernate(request);
		ConCueCuentaDAO cuentaDAO = new ConCueCuentaDAO(session);
		ConPcoPartidaContableDAO partidaContableDAO = new ConPcoPartidaContableDAO(session);
		ConDpaDetallePartidaDAO  detallePartidaDAO = new ConDpaDetallePartidaDAO(session);
		ConSacSaldosAnterioresCuentaDAO saldosAnterioresCuentaDAO = new ConSacSaldosAnterioresCuentaDAO(session);
		CierreAnualForm cierreAnualForm = (CierreAnualForm) form;
		String usuarioConectado = cierreAnualForm.getUsuarioConectado().getNombreUsuario();
		Transaction tx = partidaContableDAO.getSession().beginTransaction();
		try{
			/**Liquidacion de gastos**/
			//! se toman las cuentas de gastos de nivel 3, a partir de saldos anteriores
			
			/*(Vie 19 Feb 2010) 
			 * 
			 * Según explicacion de Carmen Colindres, en la partida deben aparecer las cuentas  posteables, no las de mayor,
			 * se utilizará el metodo findCuentasParaCierre2   que ademas excluye las cuentas que tienen saldo 0.
			 * 
			 * */
			String fechaC ="";
			Double totalIngresos= new Double(0.0);
			Double totalGastos= new Double(0.0);
			SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy");
			fechaC = sdf.format(cierreAnualForm.getFechaCierreD());
			Integer intMes = new Integer(fechaC.substring(3,5));
			Integer intAnio = new Integer(fechaC.substring(6,10));
			//List<ConSacSaldosAnterioresCuenta> listaGastos =saldosAnterioresCuentaDAO.findCuentasParaCierre(4, 3,intMes,intAnio);
			List<ConSacSaldosAnterioresCuenta> listaGastos =saldosAnterioresCuentaDAO.findCuentasParaCierre2(4,intMes,intAnio);
			//extraemos el total de saldos en la cuenta de gastos
			totalGastos = obtenerTotalSaldos(listaGastos);
			
			//se toma la cuenta de perdidas y ganancias definida en el formulario
			ConCueCuenta cuentaPerdidasYGanancias = cuentaDAO.findById(cierreAnualForm.getPerdidasGananciasId());
			
			if(totalGastos>0){
				//Creamos la partida por liquidacion de gastos para el periodo establecido en el formulario.
				ConPcoPartidaContable partidaCierreGastos = crearPartida(partidaContableDAO.nextId(), cierreAnualForm.getFechaCierreD(), null, conceptoCierreGastos+intAnio, usuarioConectado, 1, null, "F", null, null,partidaContableDAO.getLastComprobante(intAnio,intMes)+1);
				partidaContableDAO.save( partidaCierreGastos);
				
				
				detallePartidaDAO.save(crearDetalle( partidaCierreGastos, cuentaPerdidasYGanancias, null, conceptoCierreGastos+intAnio, totalGastos, 0));
				//creamos la contra partida recorriendo la lista de cuentas de gastos
				generarDetalles( partidaCierreGastos, listaGastos, 1,request);
			}else{
				mensajes("error.cierreAnual.noGastos",request, errors);
			}
			/*aparentemente no actualiza las cuentas padres de las cuentas de gastos*/
			
			/**Liquidacion de Ingresos**/
			//!se toman las cuentas de nivel 3 a partir de saldos anteriores
			
			/*(Vie 19 Feb 2010) 
			 * 
			 * Según explicacion de Carmen Colindres, en la partida deben aparecer las cuentas  posteables, no las de mayor,
			 * se utilizará el metodo findCuentasParaCierre2   que ademas excluye las cuentas que tienen saldo 0.
			 * 
			 * */
			//!List<ConSacSaldosAnterioresCuenta> listaIngresos = saldosAnterioresCuentaDAO.findCuentasParaCierre(5, 3,intMes,intAnio);
			List<ConSacSaldosAnterioresCuenta> listaIngresos = saldosAnterioresCuentaDAO.findCuentasParaCierre2(5,intMes,intAnio);
			//Creamos la partida por liquidacion de ingresos para el periodo establecido en el formulario.
			//extraemos el total de saldos en la cuenta de ingresos
			totalIngresos = obtenerTotalSaldos(listaIngresos);
			
			if(totalIngresos>0){
				ConPcoPartidaContable  partidaCierreIngresos = crearPartida(partidaContableDAO.nextId(), cierreAnualForm.getFechaCierreD(), null,  conceptoCierreIngresos+intAnio, usuarioConectado, 1, null, "F", null, null,  partidaContableDAO.getLastComprobante(intAnio,intMes)+1);
				partidaContableDAO.save(partidaCierreIngresos);
				
				
				detallePartidaDAO.save(crearDetalle(partidaCierreIngresos, cuentaPerdidasYGanancias, null, conceptoCierreIngresos+intAnio, totalIngresos, 1));
				//creamos la contra partida recorriendo la lista de cuentas de ingresos
				generarDetalles(partidaCierreIngresos, listaIngresos, 0,request);
			}else{
				mensajes("error.cierreAnual.noIngresos",request, errors);
			}
			

			/**calculo de la diferencia entre total de ingresos y el total de costos/gastos**/
			Double diferencia = totalIngresos - totalGastos;
			if(diferencia>0 ){
				//indica que this year si hubieron utilidades/ganancias que se iran a reserva y a excedentes del year
				
				/**Obtencion de reservas**/
				List<ConCueCuenta> listaReservas = cuentaDAO.findCuentasReservaPosteables();
				Double temp = new Double(0.0);// en temp se coloca el monto total destinado a reservas
				
				if(!listaReservas.isEmpty()){
					//se crea la partida por obtencion de reservas para el periodo establecido
					ConPcoPartidaContable partidaCierreReservas = crearPartida(partidaContableDAO.nextId(), cierreAnualForm.getFechaCierreD(), null, conceptoCierreReservas+intAnio, usuarioConectado, 1, null, "F", null, null, partidaContableDAO.getLastComprobante(intAnio,intMes)+1);
					partidaContableDAO.save(partidaCierreReservas);
					
					//actualizando cuentas de reservas y creando contra partida (detalle de partida)
					Double aReserva = new Double(0);
					Iterator<ConCueCuenta> it = listaReservas.iterator();
					while(it.hasNext()){
						ConCueCuenta cuenta = it.next();
						aReserva = (cuenta.getCuePorcentaje()/100)*diferencia;
						actualizarSaldos(cuenta, 0, aReserva,request);//actualizamos la cuenta de reserva y sus padres.
						detallePartidaDAO.save(crearDetalle(partidaCierreReservas, cuenta, null, conceptoCierreReservas+intAnio, aReserva, 1));
						temp +=aReserva;
					}
					//se crea el detalle con el total que se destinara a reserva
					detallePartidaDAO.save(crearDetalle(partidaCierreReservas, cuentaPerdidasYGanancias, null, conceptoCierreReservas+intAnio, temp, 0));
					
				}else{
					mensajes("error.cierreAnual.noReservas",request,errors);
				}
				
				/**se crea la partida de liquidacion de utilidades**/
				//se toma la cuenta de excedentes definida en el formulario
				ConCueCuenta cuentaExcedentes = cuentaDAO.findById(cierreAnualForm.getExcedentesId());
				ConPcoPartidaContable partidaUtilidades = crearPartida(partidaContableDAO.nextId(), cierreAnualForm.getFechaCierreD(), null, conceptoCierreUtilidades+intAnio, usuarioConectado, 1, null, "F", null, null, partidaContableDAO.getLastComprobante(intAnio,intMes)+1);
				partidaContableDAO.save(partidaUtilidades);
				
				//actualizamos los excedentes
				diferencia -= temp;
				//salvamos el detalle de la partida en le cual se colocan en el debe el saldo total de perdidas y ganancias
				detallePartidaDAO.save(crearDetalle(partidaUtilidades, cuentaPerdidasYGanancias, null, conceptoCierreUtilidades+intAnio, diferencia, 0));
				//salvamos el detalle de la partida en el cual se coloca en el haber el salto de perdidas y ganancias
				detallePartidaDAO.save(crearDetalle(partidaUtilidades, cuentaExcedentes, null, conceptoCierreUtilidades+intAnio, diferencia, 1));
				
				//actualizamos la cuenta de utilidades
				actualizarSaldos(cuentaExcedentes, 0, diferencia,request);
			}else if(diferencia != 0){
								
				//indica que this year hubieron perdidas y que se iran los fondos a la cuenta de deficit
				ConCueCuenta deficit = cuentaDAO.findById(cierreAnualForm.getDeficitId());
				ConPcoPartidaContable partidaDeficit = crearPartida(partidaContableDAO.nextId(),cierreAnualForm.getFechaCierreD(),null,conceptoCierreDeficit + intAnio,usuarioConectado,1,null,"F",null,null,partidaContableDAO.getLastComprobante(intAnio,intMes)+1);
				partidaContableDAO.save(partidaDeficit);
				
				//salvamos el detalle de la partida en le cual se colocan en el debe el saldo total de perdidas y ganancias
				detallePartidaDAO.save(crearDetalle(partidaDeficit, deficit, null, conceptoCierreUtilidades+intAnio, (diferencia*-1), 0));
				//salvamos el detalle de la partida en el cual se coloca en el haber el salto de perdidas y ganancias
				detallePartidaDAO.save(crearDetalle(partidaDeficit, cuentaPerdidasYGanancias, null, conceptoCierreUtilidades+intAnio, (diferencia*-1), 1));
				
				//actualizamos la cuenta de deficit
				actualizarSaldos(deficit, diferencia,0,request);
			}
			
			
			/**se generan las partidas de cierre de balance**/
			//extraemos todas la cuentas acreedoras
			List<ConSacSaldosAnterioresCuenta> cuentasAcreedoras = saldosAnterioresCuentaDAO.findCuentas(0, 0, 0,intMes,intAnio);
			Iterator a = cuentasAcreedoras.iterator();
			while(a.hasNext()){
				ConSacSaldosAnterioresCuenta ca = (ConSacSaldosAnterioresCuenta) a.next();
				System.out.println("Cuentas acreeedoras no retroactivas: "+ ca.getConCueCuenta().getCueNombre());	
			}
			
			//extraemos todas la cuentas deudoras
			List<ConSacSaldosAnterioresCuenta> cuentasDeudoras = saldosAnterioresCuentaDAO.findCuentas(1, 0, 0,intMes,intAnio);
			
			Iterator e = cuentasDeudoras.iterator();
			while(e.hasNext()){
				ConSacSaldosAnterioresCuenta ca = (ConSacSaldosAnterioresCuenta) e.next();
				System.out.println("Cuentas deudoras no Retro: "+ ca.getConCueCuenta().getCueNombre());	
			}
			
			
			//extraemos todas la cuentas acreedoras pero retroactivas
			List<ConSacSaldosAnterioresCuenta> cuentasAcreeRetroactivas = saldosAnterioresCuentaDAO.findCuentas(0, 1, 0,intMes,intAnio);
			
			Iterator i = cuentasDeudoras.iterator();
			while(i.hasNext()){
				ConSacSaldosAnterioresCuenta ca = (ConSacSaldosAnterioresCuenta) i.next();
				System.out.println("Cuentas acreedoras pero retroactivas: "+ ca.getConCueCuenta().getCueNombre());	
			}
			
			
			//extraemos todas la cuentas deudoras retroactivas
			List<ConSacSaldosAnterioresCuenta> cuentasDeudoRetroactivas = saldosAnterioresCuentaDAO.findCuentas(1, 1, 0,intMes,intAnio);
			
			Iterator o = cuentasDeudoras.iterator();
			while(o.hasNext()){
				ConSacSaldosAnterioresCuenta ca = (ConSacSaldosAnterioresCuenta) o.next();
				System.out.println("Cuentas deudoras pero retroactivas: "+ ca.getConCueCuenta().getCueNombre());	
			}

			
			
			/**creando partida de cierre anual**/
			ConPcoPartidaContable partidaCierreAnual = crearPartida(partidaContableDAO.nextId(), cierreAnualForm.getFechaCierreD(), null, conceptoCierreAnual+intAnio, usuarioConectado, 1, null, "F", null, null,  partidaContableDAO.getLastComprobante(intAnio,intMes)+1);
			partidaContableDAO.save(partidaCierreAnual);
			//creamos el detalle de la partida
			generarDetalles(partidaCierreAnual, cuentasDeudoRetroactivas, 0,request);
			generarDetalles(partidaCierreAnual, cuentasAcreedoras, 0,request);
			generarDetalles(partidaCierreAnual, cuentasDeudoras, 1,request);
			generarDetalles(partidaCierreAnual, cuentasAcreeRetroactivas, 1,request);
			
			
			/**creando partida de apertura del siguiente periodo**/
			//setear primer dia del aÃ±o
			ElapsedTime elap = new ElapsedTime();
			intAnio ++;
			ConPcoPartidaContable partidaAperturaAnual = crearPartida(partidaContableDAO.nextId(),elap.obtenerFecha(cierreAnualForm.getFechaCierreD(), 1), null,conceptoApertura+intAnio , usuarioConectado, 1, null, "F", null, null, 1);/*partidaContableDAO.getLastComprobante(intAnio,intMes)+*/
			partidaContableDAO.save(partidaAperturaAnual);
			//creamos el detalle de la partida
			generarDetalles(partidaAperturaAnual, cuentasDeudoras, 0,request);
			generarDetalles(partidaAperturaAnual, cuentasAcreeRetroactivas, 0,request);
			generarDetalles(partidaAperturaAnual, cuentasDeudoRetroactivas, 1,request);
			generarDetalles(partidaAperturaAnual, cuentasAcreedoras, 1,request);
			
			
			tx.commit();
			mensajes("error.cierreAnual.exito",request, errors);
		}catch (Exception e) {
			tx.rollback();
			e.printStackTrace();
		}finally{
			partidaContableDAO.getSession().flush();
			partidaContableDAO.getSession().clear();
			
		}
		return dml(mapping, form, request, response);
	}
	
	private int actualizarSaldos(ConCueCuenta conCueCuenta,double valorDebe, double valorHaber,HttpServletRequest request){
		 ConCueCuentaDAO conCueCuentaDAO = new ConCueCuentaDAO(getSessionHibernate(request));
		 try{
			 if(conCueCuenta.getConCueCuenta()==null){
				Double saldoActual = conCueCuenta.getCueSaldoActual();
				//preguntamos si es acreedora
				if(conCueCuenta.getCueTipoCuenta()!=1){// si no es retroactiva
					saldoActual= (conCueCuenta.getConTicTipoCuenta().getTicAcreeDeudo()==1)? saldoActual + valorDebe - valorHaber: saldoActual + valorHaber - valorDebe;
				}else{
					saldoActual= (conCueCuenta.getConTicTipoCuenta().getTicAcreeDeudo()==1)? saldoActual + valorHaber - valorDebe: saldoActual + valorDebe - valorHaber;
				}
				conCueCuenta.setCueSaldoActual(saldoActual);
				return 1;
			 }else{
			 	Double saldoActual = conCueCuenta.getCueSaldoActual();
			 	if(conCueCuenta.getCueTipoCuenta()!=1){// si no es retroactiva
					saldoActual= (conCueCuenta.getConTicTipoCuenta().getTicAcreeDeudo()==1)? saldoActual + valorDebe - valorHaber: saldoActual + valorHaber - valorDebe;
				}else{
					saldoActual= (conCueCuenta.getConTicTipoCuenta().getTicAcreeDeudo()==1)? saldoActual + valorHaber - valorDebe: saldoActual + valorDebe - valorHaber;
				}
			 	conCueCuenta.setCueSaldoActual(saldoActual);
				conCueCuentaDAO.merge(conCueCuenta);
				return 1 *actualizarSaldos(
						conCueCuentaDAO.findById(conCueCuenta.getConCueCuenta().getCueId()), valorDebe, valorHaber,request); 
			}
		 }catch(Exception e){
			 e.printStackTrace(); 
		 }
		return 0;//si algo fallÃ³
	 }
	
	
	private Double obtenerTotalSaldos(List<ConSacSaldosAnterioresCuenta> lista){
		Double respuesta = 0.00;
		Iterator<ConSacSaldosAnterioresCuenta> iterador = lista.iterator();
		while(iterador.hasNext()){
			ConSacSaldosAnterioresCuenta csc = iterador.next();
			respuesta += csc.getSacSaldoALaFecha();
		}
		return respuesta;
	}	

	private ConPcoPartidaContable crearPartida(long id,Date fecha,ConCpaConceptoPartida concepto,String otroConcepto,String usuario,int tipoPartida,Integer modulo,
			String estado,Integer chequePendiente,Integer chequeNegociable,int comprobantePartida){
		CtaChkChequePrestamo cheque = new CtaChkChequePrestamo();
		ConPcoPartidaContable partidaContable = new ConPcoPartidaContable();
		Date fechaRegistro = new Date();
		partidaContable.setPcoId(id);
		partidaContable.setPcoModulo(modulo);
		partidaContable.setAudFechaCreacion(fechaRegistro);
		partidaContable.setAudFechaModificacion(fechaRegistro);
		partidaContable.setPcoFechaIngresoPartida(fecha);
		partidaContable.setAudUsuarioCreacion(usuario);
		partidaContable.setAudUsuarioModificacion(usuario);
		partidaContable.setConCpaConceptoPartida(concepto);
		partidaContable.setPcoOtroConcepto(otroConcepto);
		partidaContable.getConTpaTipoPartida().setTpaId(tipoPartida);
		partidaContable.setPcoEstado(estado);
		partidaContable.setPcoChequePendiente(null);
		partidaContable.setCtaChkChequePrestamo(null);/*cambio a null pues daba problemas como estaba*/
		partidaContable.setPcoChequeNegociable(chequeNegociable);
		partidaContable.setPcoComprobantePartida(comprobantePartida);
		return partidaContable;
	}
	
	private ConDpaDetallePartida crearDetalle(ConPcoPartidaContable partida,ConCueCuenta cuenta,ConCpaConceptoPartida concepto,String otroConcepto,double val,int op){
		double debe = 0,haber = 0;
		switch (op) {
		case 0: debe = val;
					break;
		case 1: haber = val;
					break;
		}
		ConDpaDetallePartida detallePartida = new ConDpaDetallePartida();
		detallePartida.setConPcoPartidaContable(partida);
		detallePartida.setConCueCuenta(cuenta);
		detallePartida.setConCpaConceptoPartida(concepto);
		detallePartida.setDpaOtroConcepto(otroConcepto);
		detallePartida.setDpaValorDebe(debe);
		detallePartida.setDpaValorHaber(haber);
		return detallePartida;
	}
	
	private void generarDetalles(ConPcoPartidaContable partida,List<ConSacSaldosAnterioresCuenta> lista,int op,HttpServletRequest request){
		ConDpaDetallePartidaDAO detallePartidaDAO = new ConDpaDetallePartidaDAO(getSessionHibernate(request));
		Iterator<ConSacSaldosAnterioresCuenta> it = lista.iterator();
		while(it.hasNext()){
			ConSacSaldosAnterioresCuenta cuentaAnterior = it.next();
			ConDpaDetallePartida detPar = 
							crearDetalle(partida, cuentaAnterior.getConCueCuenta(),
										null, partida.getPcoOtroConcepto(),cuentaAnterior.getSacSaldoALaFecha(),op);
			detallePartidaDAO.save(detPar);
		}
	}
	
	public ActionForward apertura(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response) {
		
		/**Este metodo Setea fecha Fin a las cuentas de ahorro que tengan tipo de ahorro con fecha fin**/
		/*int tipoAhorro = 4;
		
		CtaAscAsociadoDAO asociadoDAO = new CtaAscAsociadoDAO();
		CtaCasCuentaAsociadoDAO cuentasDAO = new CtaCasCuentaAsociadoDAO();
		CtaTahTipoAhorroDAO tahDAO = new CtaTahTipoAhorroDAO();
		
		CtaTahTipoAhorro tah = tahDAO.findById(tipoAhorro);
		Transaction tx = cuentasDAO.getSession().beginTransaction();
		try{
			List listaAsociado = cuentasDAO.findCuentasActualizacionDeFechaCierre(tipoAhorro);
			for (Iterator iterator = listaAsociado.iterator(); iterator.hasNext();) {
				Long casCuenta = (Long) iterator.next();
				CtaCasCuentaAsociado cuenta = cuentasDAO.findById(casCuenta);
				cuenta.setCasFechaCierre(tah.getTahFechaFin());
				cuentasDAO.merge(cuenta);
				
			}
			tx.commit();
		}catch(Exception e){
			tx.rollback();
			e.printStackTrace();
		}finally{
			
			cuentasDAO.getSession().flush();
			cuentasDAO.getSession().clear();
			cuentasDAO.getSession().close();
		}*/
		
		/**Metodo creado para generar partida de apertura en contabilidad**/
		/**creando partida de apertura del siguiente periodo**/
		int intAnio =2009;
		int intMes = 01;
		String conceptoApertura = "Partida de apertura de ejercicio  ";
				
		ConPcoPartidaContableDAO partidaContableDAO = new ConPcoPartidaContableDAO(getSessionHibernate(request));
		ConSacSaldosAnterioresCuentaDAO saldosAnterioresCuentaDAO = new ConSacSaldosAnterioresCuentaDAO(getSessionHibernate(request));
		SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy");
		
		Transaction tx = partidaContableDAO.getSession().beginTransaction();
		try{
			ConPcoPartidaContable partidaAperturaAnual = crearPartida(partidaContableDAO.nextId(), sdf.parse("01-01-2009"), null,conceptoApertura+intAnio , "MIGRACION", 1, null, "F", null, null,1);
			partidaContableDAO.save(partidaAperturaAnual);
			
			//creamos el detalle de la partida
			/**se generan las partidas de cierre de balance**/
			//extraemos todas la cuentas acreedoras
			List<ConSacSaldosAnterioresCuenta> cuentasAcreedoras = saldosAnterioresCuentaDAO.findCuentas(0, 0, 0,intMes,intAnio);
			//extraemos todas la cuentas deudoras
			List<ConSacSaldosAnterioresCuenta> cuentasDeudoras = saldosAnterioresCuentaDAO.findCuentas(1, 0, 0,intMes,intAnio);
			//extraemos todas la cuentas acreedoras pero retroactivas
			List<ConSacSaldosAnterioresCuenta> cuentasAcreeRetroactivas = saldosAnterioresCuentaDAO.findCuentas(0, 1, 0,intMes,intAnio);
			//extraemos todas la cuentas deudoras retroactivas
			List<ConSacSaldosAnterioresCuenta> cuentasDeudoRetroactivas = saldosAnterioresCuentaDAO.findCuentas(1, 1, 0,intMes,intAnio);
			//creamos el detalle de la partida
			generarDetalles(partidaAperturaAnual, cuentasDeudoras, 0,request);
			generarDetalles(partidaAperturaAnual, cuentasAcreeRetroactivas, 0,request);
			generarDetalles(partidaAperturaAnual, cuentasDeudoRetroactivas, 1,request);
			generarDetalles(partidaAperturaAnual, cuentasAcreedoras, 1,request);
			tx.commit();
		}catch(Exception e){
			tx.rollback();
			e.printStackTrace(); 
		}
		return null;
	}
	
	public void mensajes(String msg, HttpServletRequest request, ActionErrors errors){
        errors.add(ActionMessages.GLOBAL_MESSAGE,new ActionMessage(msg));
        saveMessages(request, errors);
	}
	
	protected Map<String, String> getKeyMethodMap() {
		HashMap<String, String> map = new HashMap<String, String>();
		map.put("cmd.cierreAnual.dml","dml");
		map.put("cmd.cierreAnual.realizarCierre","realizarCierre");
		map.put("cmd.cierreAnual.apertura", "apertura");
		return map;
	}
}